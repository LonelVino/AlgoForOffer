# 排序算法

[TOC]

[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

给你一个整数数组 `nums`，将该数组升序排列

**示例 1：**

```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**示例 2：**

```
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

**提示：**

1. `1 <= nums.length <= 50000`
2. `-50000 <= nums[i] <= 50000`

 **常见的排序算法**

![image-20200331104459670](排序算法.assets/image-20200331104459670.png)

### 方法一：快速排序

 **主要思想**：

通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小
然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序

**基本思路：**

我们定义函数` randomized_quicksort(nums, l, r)` 为对 `nums `数组里 [l,r][l,r] 的部分进行排序
每次先调用 `randomized_partition` 划分函数对 `nums `数组里 [l,r][l,r] 的部分进行划分，并返回**分界值的下标** `pos`
然后按上述将的递归调用`randomized_quicksort(nums, l, pos - 1) `和 `randomized_quicksort(nums, pos + 1, r)` 即可。

**核心：划分函数的实现**

划分函数一开始需要确定一个分界值（主元 `pivot)`，然后再进行划分。
主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 [l,r][l,r] 里的数**等概率随机**一个作为我们的主元，再将主元放到区间末尾，进行划分。

整个划分函数 `partition `主要涉及两个指针 `i` 和 `j`，一开始` i = l - 1，j = l`。
我们需要实时维护两个指针使得任意时候，对于任意数组下标 `k`，我们有如下条件成立：<img src="排序算法.assets/image-20200401225000536.png" alt="image-20200401225000536" style="zoom:80%;" />

我们每次移动指针 `j`，如果 ${nums}[j]> pivot$，我们只需要继续移动指针 `j` ，即能使上述三个条件成立
否则我们需要将指针 `i` 加一，然后交换$ {nums}[i]$ 和 ${nums}[j]$，再移动指针 `j` 才能使得三个条件成立。

当 `j` 移动到 `r-1` 时结束循环，此时我们可以由上述三个条件知道 [l,i][l,i] 的数都小于等于主元 `pivot`，[i+1,r-1][i+1,r−1] 的数都大于主元 `pivot`
那么我们只要交换 ${nums}[i+1]$和  $ {nums}[r]$ ，即能使得 [l,i+1][l,i+1] 区间的数都小于 [i+2,r][i+2,r] 区间的数，完成一次划分，且分界值下标为` i+1`，返回即可。

刚开始随机选了 $4$ 作为主元，与末尾元素交换后开始划分：

<img src="排序算法.assets/912_fig1.gif" alt="fig1" style="zoom:50%;" />



```python
import random
from typing import List
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomized_quicksort(nums, 0, len(nums) - 1)
        return nums

    # 定义划分函数
    def randomized_partition(self, nums, l, r):
        pivot = random.randint(l, r)
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1
        for j in range(l, r):
            # 如果nums[j] < pivot, 将指针 `i` 加一，然后交换{nums}[i]和{nums}[j]
            if nums[j] < nums[r]:
                i += 1
                nums[j], nums[i] = nums[i], nums[j]
    # 交换 {nums}[i+1]和  {nums}[r]
        i += 1
        nums[i], nums[r] = nums[r], nums[i]
        return i  # 返回划分的下标

    # 定义排序函数

    def randomized_quicksort(self, nums, l, r):
        if r - l <= 0:
            return
        mid = self.randomized_partition(nums, l, r)
        self.randomized_partition(nums, l, mid - 1)
        self.randomized_quicksort(nums, mid + 1, r)
```



**复杂度分析**

时间复杂度：基于随机选取主元的快速排序时间复杂度为期望$ O(n\log n)$

空间复杂度：$O(h)$,  其中 $h$  为快速排序递归调用的层数,  最坏情况下需 $O(n)$ 的空间,   最优情况下每次都平衡,  空间复杂度为 $O(\log n)$。

### 方法二：堆排序

**思路和算法**

- 先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素
- 将其与末尾元素交换，使末尾元素为最大值
- 然后再调整堆顶元素使得剩下的 $n-1$ 个元素仍为大根堆
- 再重复执行以上操作（初始化有$n-k$个元素的堆，交换堆中的堆顶元素与末尾元素）

对 `[4, 6, 8, 5, 9]` 这个数组堆排序:

<img align="left" src="排序算法.assets/912_fig2.gif" alt="fig2" style="zoom:50%;" /><img src="https://assets.leetcode-cn.com/solution-static/912_fig3.gif" alt="fig3" style="zoom:50%;" />

```python
import heapq
from typing import List
class Solution:
  
  def max_heapify(self, heap, root, heap_len):
    p = root
    # 判断p目前是不是父节点
    while p * 2 + 1 < heap_len:
      l, r = p * 2 + 1, p * 2 + 2   # l, r 分别为父节点的左子树、右子树
      #没有右子树或者右子树比左子树小时，nex指向左子树的位置；此外，nex指向右子树
      if heap_len <= r or heap[r] < heap[l]:   
        nex = l
      else:
        nex = r
      # 如果nex比父节点还大，就交换nex位置与父节点位置的值，使得父节点比左右子树都要大
      if heap[p] < heap[nex]:
        heap[p], heap[nex] = heap[nex], heap[p]
        p = nex  # 父节点位置更新为nex的位置
      else: 
        break

  # 第一次初始化堆
  def build_heap(self, heap):
    for i in range(len(heap) - 1, -1, -1):
      self.max_heapify(heap, i, len(heap))
    
  def heap_sort(self, nums):
    self.build_heap(nums)
    for i in range(len(nums) - 1, -1, -1):
      # 将堆顶元素与末尾元素进行交换，然后用除去末尾元素的数字继续初始化堆
      nums[i], nums[0] = nums[0], nums[i]
      self.max_heapify(nums, 0, i)
  
  def sortArray(self, nums: List[int]) -> List[int]:
    self.heap_sort(nums)
    return nums
```

**复杂度分析**

时间复杂度：$O(n\log n)$。初始化建堆的时间复杂度为$ O(n)$，建完堆以后需要进行 $n-1$ 次调整，一次调整（即 `maxHeapify`） 的时间复杂度为 $O(\log n)$，那么 $n-1$次调整即需要 $O(n\log n)$ 的时间复杂度。因此，总时间复杂度为 $O(n+n\log n)=O(n\log n)$。

空间复杂度：$O(1)$。只需要常数的空间存放若干变量。

# 排序数组

[力扣官方题解](https://leetcode-cn.com/u/leetcode-solution/)发布于 3 天前16.2k**官方**C++Python排序

**本题你可以选择直接调用库函数来对序列进行排序，但意义不大。由于排序算法有很多，本文只介绍三种常见的基于比较的复杂度较低的排序。**

#### 方法一：快速排序

**思路和算法**

快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。

我们定义函数 `randomized_quicksort(nums, l, r)` 为对 `nums` 数组里 [l,r][*l*,*r*] 的部分进行排序，每次先调用 `randomized_partition` 函数对 `nums` 数组里 [l,r][*l*,*r*] 的部分进行划分，并返回分界值的下标 `pos`，然后按上述将的递归调用 `randomized_quicksort(nums, l, pos - 1)` 和 `randomized_quicksort(nums, pos + 1, r)` 即可。

那么核心就是划分函数的实现了，划分函数一开始需要确定一个分界值（我们称之为主元 `pivot`)，然后再进行划分。而主元的选取有很多种方式，这里我们采用随机的方式，对当前划分区间 [l,r][*l*,*r*] 里的数等概率随机一个作为我们的主元，再将主元放到区间末尾，进行划分。

整个划分函数 `partition` 主要涉及两个指针 i*i* 和 j*j*，一开始 `i = l - 1`，`j = l`。我们需要实时维护两个指针使得任意时候，对于任意数组下标 k*k*，我们有如下条件成立：

1. l\leq k\leq i*l*≤*k*≤*i* 时，\textit{nums}[k]\leq \textit{pivot}*nums*[*k*]≤*pivot*。
2. i+1\leq k\leq j-1*i*+1≤*k*≤*j*−1 时，\textit{nums}[k]> \textit{pivot}*nums*[*k*]>*pivot*。
3. k==r*k*==*r* 时，\textit{nums}[k]=\textit{pivot}*nums*[*k*]=*pivot*。

我们每次移动指针 j*j* ，如果 \textit{nums}[j]> pivot*nums*[*j*]>*p**i**v**o**t*，我们只需要继续移动指针 j*j* ，即能使上述三个条件成立，否则我们需要将指针 i*i* 加一，然后交换 \textit{nums}[i]*nums*[*i*] 和 \textit{nums}[j]*nums*[*j*]，再移动指针 j*j* 才能使得三个条件成立。

当 j*j* 移动到 r-1*r*−1 时结束循环，此时我们可以由上述三个条件知道 [l,i][*l*,*i*] 的数都小于等于主元 `pivot`，[i+1,r-1][*i*+1,*r*−1] 的数都大于主元 `pivot`，那么我们只要交换 \textit{nums}[i+1]*nums*[*i*+1] 和 \textit{nums}[r]*nums*[*r*] ，即能使得 [l,i+1][*l*,*i*+1] 区间的数都小于 [i+2,r][*i*+2,*r*] 区间的数，完成一次划分，且分界值下标为 i+1*i*+1，返回即可。

如下的动图展示了一次划分的过程，刚开始随机选了 44 作为主元，与末尾元素交换后开始划分：

![fig1](https://assets.leetcode-cn.com/solution-static/912_fig1.gif)

- C++
- Python3

```
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }
    void randomized_quicksort(vector<int>& nums, int l, int r) {
        if (l < r){
            int pos = randomized_partition(nums, l, r);
            randomized_quicksort(nums, l, pos - 1);
            randomized_quicksort(nums, pos + 1, r);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL));
        randomized_quicksort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```

**复杂度分析**

- 时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(n\log n)*O*(*n*log*n*)，其中 n*n* 为数组的长度。详细证明过程可以见《算法导论》第七章，这里不再大篇幅赘述。
- 空间复杂度：O(h)*O*(*h*)，其中 h*h* 为快速排序递归调用的层数。我们需要额外的 O(h)*O*(*h*) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n)*O*(*n*) 的空间，最优情况下每次都平衡，此时整个递归树高度为 \log nlog*n*，空间复杂度为 O(\log n)*O*(log*n*)。

#### 方法二：堆排序

**预备知识**

- 堆

**思路和算法**

堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1*n*−1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。

如下两个动图展示了对 `[4, 6, 8, 5, 9]` 这个数组堆排序的过程：

![fig2](https://assets.leetcode-cn.com/solution-static/912_fig2.gif)

![fig3](https://assets.leetcode-cn.com/solution-static/912_fig3.gif)

- C++
- Python3

```
class Solution:
    def max_heapify(self, heap, root, heap_len):
        p = root
        while p * 2 + 1 < heap_len:
            l, r = p * 2 + 1, p * 2 + 2
            if heap_len <= r or heap[r] < heap[l]:
                nex = l
            else:
                nex = r
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break
        
    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))

    def heap_sort(self, nums):
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)
            
    def sortArray(self, nums: List[int]) -> List[int]:
        self.heap_sort(nums)
        return nums
```

**复杂度分析**

- 时间复杂度：O(n\log n)*O*(*n*log*n*)。初始化建堆的时间复杂度为 O(n)*O*(*n*)，建完堆以后需要进行 n-1*n*−1 次调整，一次调整（即 `maxHeapify`） 的时间复杂度为 O(\log n)*O*(log*n*)，那么 n-1*n*−1 次调整即需要 O(n\log n)*O*(*n*log*n*) 的时间复杂度。因此，总时间复杂度为 O(n+n\log n)=O(n\log n)*O*(*n*+*n*log*n*)=*O*(*n*log*n*)。
- 空间复杂度：O(1)*O*(1)。只需要常数的空间存放若干变量。

### 方法三：归并排序

**分治的思想**：

对一个长为$ n$ 的待排序的序列，我们将其分解成两个长度为 $\frac{n}{2}$的子序列。
每次先递归调用函数使两个子序列有序，然后我线性合并两个有序的子序列使整个序列有序。

**算法:**

定义 `mergeSort(nums, l, r)` 函数表示对 `nums` 数组里 [l,r][*l*,*r*] 的部分进行排序，流程如下：

- 递归调用函数 `mergeSort(nums, l, mid)` 对 `nums` 数组里 $[l,mid]$ 部分进行排序。
- 递归调用函数 `mergeSort(nums, mid + 1, r) `对 `nums `数组里$[mid +1,r]$ 部分进行排序。
- 此时 nums 数组里$[l,mid]$和 两$[mid +1,r]$ 个区间已经有序，我们对两个有序区间**线性归并**即可使 `nums `数组里 [l,r][l,r] 的部分有序。

**线性归并:**  

- 维护两个指针 $i$ 和 $j$,   表示当前考虑到  里  $[l,mid]$ 的第 $i$ 个位置和$[mid +1,r]$的第 $j$ 个位置。

- 如果 $nums[i] < nums[j] $，那么我们就将 $nums[i]$ 放入临时数组` tmp `中并让` i += 1` ，即指针往后移。

- 否则我们就将 $nums[j]$ 放入临时数组 `tmp `中并让` j += 1 `。

- 如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入` tmp `数组中即可。

  两个有序数组线性归并的过程：

<img src="https://assets.leetcode-cn.com/solution-static/912_fig4.gif" alt="fig4" style="zoom:50%;" />

函数递归调用的入口为 `mergeSort(nums, 0, nums.length - 1)`，递归结束当且仅当 `l >= r`。

```python
from typing import List

class Solution:
    def mergeSort(self, nums, l, r):
        if l == r:
            return
        mid = (l + r) // 2
        self.mergeSort(nums, l, mid)
        self.mergeSort(nums, mid + 1, r)
        tmp = []
        i, j = l, mid + 1
        while i <= mid or j <= r:
            if i > mid or (j <= r and nums[j] < nums[i]):
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1
        nums[l:r + 1] = tmp

    def sortArray(self, nums: List[int]) -> List[int]:
        self.mergeSort(nums, 0, len(nums) - 1)
        return nums
```

**复杂度分析**

- 时间复杂度：$O(n\log n)$  
- 空间复杂度：$O(n)$。我们需要额外 $O(n)$空间的 $tmp$ 数组，且归并排序递归调用的层数最深为 $\log_2 n$，所以我们还需要额外的 $O(\log n )$ 的栈空间，所需的空间复杂度即为 $O(n+\log n) = O(n)$。




## [面试题40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

**示例 1：**

```powershell
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

**示例 2：**

```powershell
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

**限制：**

- `0 <= k <= arr.length <= 10000`
- `0 <= arr[i] <= 10000`

### 方法一.排序

```PYTHON
class Solution:
  def getLeastNumbers(self, arr: List[int],  k: int) -> List[int]:
    arr.sort()
    return arr[0:k]
```

**复杂度分析**

- 时间复杂度：$O(n\log n)$，其中 n*n* 是数组 `arr` 的长度。算法的时间复杂度即排序的时间复杂度。
- 空间复杂度：$O(\log n)$，排序所需额外的空间复杂度为 $O(\log n)$。

### 方法二：堆

我们用一个大根堆实时维护数组的前 $k$小值.  
首先将前$ k$ 个数插入**大根堆**中，随后从第 $k+1$ 个数开始遍历，如果当前**遍历到的数比大根堆的堆顶的数要小**，**就把堆顶的数弹出**，**再插入当前遍历到的数**。最后将大根堆里的数存入数组返回即可。
 Python 语言中的对为**小根堆**，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 $k$ 小值。

> 大顶堆：每个结点的值都**大于**或**等于**其左右孩子结点的值
> 小顶堆：每个结点的值都**小于**或**等于**其左右孩子结点的值
> 堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素

<img align="left" src="LeetCode -- Python 学习之旅.assets/image-20200320093918300.png" alt="image-20200320093918300" style="zoom:67%;" />

#### Python标准库模块之heapq

heapq有两种方式创建堆:
（1）使用一个空列表，然后使用`heapq.heappush()`函数把值加入堆中
（2）使用`heap.heapify(list)`转换*列表*成为堆结构

```python
import heapq

# 第一种
nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
    heapq.heappush(heap, num)  # 加入堆
    
# 第二种
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)
print([heapq.heappop(heap) for _ in range(len(nums))])  # 堆排序结果
# out: [1, 2, 3, 5, 23, 54, 132]
```

**访问堆内容**

堆创建好后，可以通过`heapq.heappop() `函数弹出堆中最小值。

```python
import heapq
nums = [2, 43, 45, 23, 12]
heapq.heapify(nums)
print(heapq.heappop(nums))   # out: 2
```

如果需要删除堆中最小元素并加入一个元素，可以使用`heapq.heaprepalce()` 函数

```python
import heapq
nums = [1, 2, 4, 5, 3]
heapq.heapify(nums)
heapq.heapreplace(nums, 23)
print([heapq.heappop(nums) for _ in range(len(nums))])   # out: [2, 3, 4, 5, 23]
```

**解题代码**

```python
import heapq
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0:
            return list()

        hp = [-x for x in arr[:k]]
        heapq.heapify(hp)
        for i in range(k, len(arr)):
            if -hp[0] > arr[i]:
                heapq.heappop(hp)
                heapq.heappush(hp, -arr[i])
        ans = [-x for x in hp]
        return ans
```

**复杂度分析**

时间复杂度：$O(n\log k)$，其中 n*n* 是数组 `arr` 的长度。由于大根堆实时维护前 $k$ 小值，所以插入删除都是 $O(\log k)$ 的时间复杂度，最坏情况下数组里$ n$ 个数都会插入，所以一共需要 $O(n\log k)$ 的时间复杂度。

空间复杂度：$O(k)$，因为大根堆里最多 $k$个数。

如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入 `tmp` 数组中即可。