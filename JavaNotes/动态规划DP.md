# 动态规划DP

## 背包问题

### 常规解

<img src="动态规划DP.assets/image-20200324185333668.png" alt="image-20200324185333668" style="zoom:80%;" />

1. 面对当前商品有两种可能性：

　　　　第一，**包的容量比该商品体积小，装不下**，此时的价值与前$i-1$个的价值是一样的，即$V(i,j)=V(i-1,j)$；

　　　　第二，**还有足够的容量可以装该商品**，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即$V(i,j)=max｛ V(i-1,j)，V(i-1,j-w(i))+v(i) ｝$
					其中$V(i-1,j)$表示不装，$V(i-1,j-w(i))+v(i) $表示装了第i个商品，**背包容量减少$w(i)$但价值增加了$v(i)$；**

　　　　由此可以得出递推关系式：

　　　　1) $ j<w(i)  \quad V(i,j)=V(i-1,j)$     不装

　　　　2) $ j>=w(i)  \quad V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝$  在装与不装选择最优一个

2. 然后一行一行的填表，

　　1) 如，$i=1，j=1，w(1)=2，v(1)=3，有j<w(1)，故V(1,1)=V(1-1,1)=0；$

　　2) 又如$i=1，j=2，w(1)=2，v(1)=3$，有$j=w(1)$, 故$V(1,2)=max｛ V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3$；

　　3) 如此下去，填到最后一个，$i=4，j=8，w(4)=5，v(4)=6，$有$j>w(4$)，故$V(4,8)=max｛ V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10$；
所以填完表如下图：
<img src="动态规划DP.assets/1065397-20170328165055498-1241953671.png" alt="img" style="zoom:67%;" />

```java
 void FindMax()//动态规划
 2 {
 3     int i,j;
 4     //填表
 5     for(i =1; i <= number; i++)
 6     {
 7         for(j = 1; j <= capacity; j++)
 8         {
 9             if(j < w[i])//包装不进
10             {
11                 V[i][j] = V[i-1][j];
12             }
13             else//能装
14             {
15                 if(V[i-1][j] > V[i-1][j-w[i]] + v[i])//不装价值大
16                 {
17                     V[i][j ]= V[i-1][j];
18                 }
19                 else//前i-1个物品的最优解与第i个物品的价值之和更大
20                 {
21                     V[i][j] = V[i-1][j-w[i]] + v[i];
22                 }
23             }
24         }
25     }
26 }
```

3. 表格填完，最优解即是$V(number,capacity)=V(4,8)=10$，但还不知道解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：

　　　　1) $V(i,j)=V(i-1,j)$时，说明没有选择第$i $个商品，则回到$V(i-1,j)$；

　　　　2) $V(i,j)=V(i-1,j-w(i))+v(i)$时，说明装了第$i$个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到$V(i-1,j-w(i))$；

　　　　3) 一直遍历到$i＝0$结束为止，所有解的组成都会找到。

　4.  如上例子:

　　　　1) 最优解为$V(4,8)=10$，而$V(4,8)!=V(3,8)$
						却有$V(4,8)=V(3,8-w(4))$$+v(4)=V(3,3)+6=4+6=10$，所以第`4`件商品被选中，并且回到$V(3,8-w(4))=V(3,3)$；

　　　　2) 有$V(3,3)=V(2,3)=4$，所以第`3`件商品没被选择，回到$V(2,3)$；

　　　　3) 而$V(2,3)!=V(1,3)$
						却有$V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4$，所以第`2`件商品被选中，并且回到$V(1,3-w(2))=V(1,0)$；

　　　　4) 有$V(1,0)=V(0,0)=0$，所以第`1`件商品没被选择；<img src="动态规划DP.assets/1065397-20170328165219092-1883633849.png" alt="img" style="zoom: 33%;" />

5. 利用动态规划解决此问题的效率即是填写此张表的效率，
   **时间效率**为$O(number\times capacity)=O(n\times c)$
   由于用到二维数组存储子问题的解，
   **空间效率**为$O(n\times c)$；

```java
void FindWhat(int i, int j)//寻找解的组成方式
{
    if(i >=  0)
    {
        if(V[i][j] == V[i -1][j])//相等说明没装
        {
            item[i] = 0;//全局变量，标记未被选中
            FindWhat(i-1,j);
        }
        else if( j-w[i]>=0 && V[i][j] == V[i-1][j - w[i]] + v[i] )
        {
            item[i]=1;//标记已被选中
            FindWhat(i-1,j-w[i]);//回到装包之前的位置
        }
    }
```

### 空间优化

将$V$缩减成一维数组，从而达到优化空间的目的
状态转移方程转换为 $B(j)= max{B(j), B(j-w(i))+v(i)}$<img src="动态规划DP.assets/1065397-20170328165423936-1589228819.png" alt="img" style="zoom:47%;" /><img src="动态规划DP.assets/1065397-20170328165439139-1416618143.png" alt="img" style="zoom:67%;" />

同样以上述例子中i=3时来说明，有:

　　　　1) $i=3，j=8，w(3)=4，v(3)=5$，有$j>w(3)$，则$B(8)=max｛B(8)，B(8-w(3))+v(3)｝=max｛B(8)，B(4)+5｝=max｛7，4+5｝=9$；

　　　　2) `j- -`即$j=7$，有$j>w(3)$，则$B(7)=max｛B(7)，B(7-w(3))+v(3)｝=max｛B(7)，B(3)+5｝=max｛7，4+5｝=9$；

　　　　3) `j- -`即$j=6$，有$j>w(3)$，则$B(6)=max｛B(6)，B(6-w(3))+v(3)｝=max｛B(6)，B(2)+5｝=max｛7，3+5｝=8$；

　　　　4) `j-- `即$j=5$，有$j>w(3)$，则$B(5)=max｛B(5)，B(5-w(3))+v(3)｝=max｛B(5)，B(1)+5｝=max｛7，0+5｝=7$；

　　　　5) `j-- `即$j=4$，有$j＝w(3)$，则$B(4)=max｛B(4)，B(4-w(3))+v(3)｝=max｛B(4)，B(0)+5｝=max｛4，0+5｝=5$；

　　　　6) `j–-`即$j=3$，有$j<w(3)$，继续访问数组会出现越界，所以本轮操作停止，B(0)到B(3)的值保留上轮循环（$i=2$时）的值不变，进入下一轮循环`i++`；

 ![img](https://images2015.cnblogs.com/blog/1065397/201703/1065397-20170328165558420-477181327.png)

如果j不逆序而采用正序`j=0...capacity`，如上图所示，当$j=8$时应该有$B(8)=B(8-w(3))+v(3)=B(4)+5$，然而此时的$B(4)$已经在`j=4`的时候被修改过了，原来的$B(4)=4$，现在$B(4)=5$，所以计算得出$B(8)=5+5=10$，显然这于正确答案不符合

```java
 void FindMaxBetter()//优化空间后的动态规划
 2 {
 3     int i,j;
 4     for(i=1;i<=number;i++)
 5     {
 6         for(j=capacity;j>=0;j--)
 7         {
 8             if(B[j]<=B[j-w[i]]+v[i] && j-w[i]>=0 )//二维变一维
 9             {
10                 B[j]=B[j-w[i]]+v[i];
11             }
12         }
13     }
14 }
```

其实简单的来说，`dp`就是用数组来递推下一个状态。

动态规划算法通常基于一个**递推公式**及一个或多个**初始状态**。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。

## [面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/)

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数

**示例 1：**

```
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
```

**示例 2：**

```
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
```

**示例 3：**

```
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
```

#### 回溯法

递推方程：$dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])$

空间$O(n)$

```c++
class Solution {
    public int massage(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);  //例如，比较nums[1] 和 nums[2] + nums[0]
        }
        return dp[n - 1];
    }
}
```

### DP动态规划

空间优化到$O(1)$

```c++
class Solution {
    public int massage(int[] nums) {
        int a = 0, b = 0;
        for (int i = 0; i < nums.length; i++) {
            int c = Math.max(b, a + nums[i]);
            a = b;  // a 用来记录上上次的结果，用于和新的相加与上一次的结果进行比较
            b = c;  // b用来记录上一次比较得出的结果，以便下一次进行比较
        }
        return b;
    }
}
```

